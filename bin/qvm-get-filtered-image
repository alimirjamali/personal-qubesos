#!/usr/bin/python3 -O

# The Qubes OS Project, http://www.qubes-os.org
#
# Ali's personal Qubes OS improvements, http://www.mirjamali.com
#
# Copyright (C) 2024  Ali Mirjamai <ali@mirjamali.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import argparse
import qubesadmin
import qubesadmin.features
import qubesimgconverter
import numpy
from qubesimgconverter import hex_to_int

parser = argparse.ArgumentParser(
        description='Secure copy of images between virtual machines',
        epilog='Both SRC and DST may specify format in gm(1) way,\n'
        'i.e. png:aqq.gif')

parser.add_argument('vmname', metavar='VMNAME', help='Source VM')
parser.add_argument('colour', metavar='COLOUR', help='Colour')
parser.add_argument('src', metavar='SRC', help='Path inside source VM')
parser.add_argument('dst', metavar='DST', help='Destination path in this VM')
parser.add_argument("--ANSI", action="store_true", help="Print ANSI X3.64 "\
        "(ISO/IEC 6429) color representation of image in color capable tty")
parser.add_argument("--filter", type=str, default="custom", choices=["custom",\
        "tint", "overlay","thin-border", "thick-border", "untouched", "invert"],\
        help="Filter to perform on the image. 'custom' is the default i.e.: "\
        "Program will look for 'imgfilter' in qube features. If that feature "\
        "exits, its value should indicate default filter for that qube. If "\
        "'imgfilter' is missing or it contains an invalid filter, 'tint' will "\
        "be the default.")
parser.add_argument("--mirror", type=str, default="none", choices=\
        ["vertical", "vertically", "horizontal", "horizontally", "both"],\
        help="Mirror image in one or both axes.")

'''Note to self: qubesimgconverter.Image.tint is using numpy's old- '''
'''deprecated binary mode of fromstring. as it behaves surprisingly-'''
'''on unicode inputs. Use of frombuffer is recommended. However,-   '''
'''this should  not be a security hazard here. No need for patches. '''

class Image(qubesimgconverter.Image):
    def __init__(self, rgba, size):
          super().__init__(rgba, size) 

    def ANSI(self):
        '''Printing representation of image with ANSI escape codes'''

        pixels = numpy.frombuffer(self._rgba, dtype='B').reshape(\
                self.height, self.width, 4)
        for row in pixels:
            for pixel in row:
                r, g, b, a = pixel[:]
                print("\033[48;2;%d;%d;%dm  " % (r, g, b), end='')
            print("\033[0m")

    def overlay(self, colour):
        ''' Overlay image on a solid block of color, using its Alpha channel '''

        rb, gb, bb = hex_to_int(colour)

        pixels = numpy.frombuffer(self._rgba, dtype='B').reshape(\
                self.height * self.width, 4)
        r = pixels[:, 0].astype('u4')
        g = pixels[:, 1].astype('u4')
        b = pixels[:, 2].astype('u4')
        a = pixels[:, 3].astype('u4')
        r = (((a * r) + (255 - a) * rb) / 256).astype('B')
        g = (((a * g) + (255 - a) * gb) / 256).astype('B')
        b = (((a * b) + (255 - a) * bb) / 256).astype('B')
        a[:] = 0
        pixelso = numpy.column_stack((r, g, b, a.astype('B')))
        return self.__class__(rgba=pixelso.tobytes(), size=self._size)

    def border(self, colour, percent):
        ''' Apply a border of colour to image. No antialiasing for now '''
        ''' percent if minimum of (width, height) '''

        rb, gb, bb = hex_to_int(colour)
        if  min(self.height, self.width) <= 16:
            width = 1
        else:
            width = int(min(self.height, self.width) * percent / 100.)

        pixels = numpy.frombuffer(self._rgba, dtype='B').reshape(\
                self.height, self.width, 4)
        pixelsb = pixels.astype('u4')
        pixelsb[0:width, :] = rb, gb, bb, 0
        pixelsb[:, 0:width] = rb, gb, bb, 0
        pixelsb[-width:, :] = rb, gb, bb, 0
        pixelsb[:, -width:] = rb, gb, bb, 0
        return self.__class__(rgba=pixelsb.astype('B'), size=self._size)

    def untouched(self):
        ''' Returning the untouched image '''
        return self

    def invert(self):
        ''' Inverting image for a paranoid effect '''

        pixels = numpy.frombuffer(self._rgba, dtype='B').reshape(\
                self.height * self.width, 4)
        ri = 255 - pixels[:, 0]
        gi = 255 - pixels[:, 1]
        bi = 255 - pixels[:, 2]
        a = pixels[:, 3]
        pixelst = numpy.column_stack((ri, gi, bi, a))
        return self.__class__(rgba=pixelst.tobytes(), size=self._size)

    def mirror(self, axes):
        ''' Mirror/flip image vertically. I guess no one would use this'''

        pixels = numpy.frombuffer(self._rgba, dtype='B').reshape(\
                self.height, self.width, 4)
        pixels = numpy.flip(pixels, axes)
        return self.__class__(rgba=pixels.astype('B'), size=self._size)

def main():
    args = parser.parse_args()

    app = qubesadmin.Qubes()
    try:
        vm = app.domains[args.vmname]
    except KeyError:
        vm = None

    if vm is None:
        parser.error('No such VM: {0}'.format(args.vmname))

    img=Image.get_from_vm(vm, args.src)
    
    filter = args.filter
    if filter == "custom":
        filter = vm.features.get("imgfilter", "tint")

    ''' Python 3.11 is nicely shipped with Q4.2, so we use match statement'''
    match filter:
        case "tint":
            img=img.tint(args.colour)
        case "overlay":
            img=img.overlay(args.colour)
        case "thin-border":
            img=img.border(args.colour, 10./3.)
        case "thick-border":
            img=img.border(args.colour, 20./3.)
        case "untouched":
            img=img.untouched()
        case "invert":
            img=img.invert()
        case _:
            img=img.tint(args.colour)

    match args.mirror:
        case "vertical" | "vertically":
            img=img.mirror(0)
        case "horizontal" | "horizontally":
            img=img.mirror(1)
        case "both":
            img=img.mirror((0,1))
        case _:
            pass

    if args.ANSI:
        img.ANSI()

    img.save(args.dst)

if __name__ == '__main__':
    main()

# vim: ft=python sw=4 ts=4 et
